<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Doghouse Board Game</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #222;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 {
      margin: 5px 0;
    }
    #game-container {
      display: flex;
      gap: 20px;
      margin-top: 10px;
      align-items: flex-start;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(13, 32px);
      grid-auto-rows: 32px;
      gap: 2px;
      background: #111;
      padding: 8px;
      border-radius: 8px;
    }
    .cell {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
      user-select: none;
      box-sizing: border-box;
    }
    .track {
      background: #444;
    }
    .start {
      border: 2px solid #fff;
    }
    .home {
      background: #222;
      border: 1px solid #777;
    }
    .doghouse {
      background: #333;
      border: 1px dashed #888;
    }
    .selected {
      outline: 2px solid yellow;
    }
    .peg {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }
    .peg-R { background: #ff4b4b; }
    .peg-Y { background: #ffd84b; }
    .peg-G { background: #4bff7a; }
    .peg-P { background: #b14bff; }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 320px;
    }
    #controls, #log, #hand-panel, #status {
      background: #111;
      padding: 8px;
      border-radius: 8px;
      font-size: 14px;
    }
    #log {
      height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .card {
      display: inline-block;
      padding: 4px 6px;
      margin: 2px;
      border-radius: 4px;
      border: 1px solid #888;
      background: #222;
      cursor: pointer;
      user-select: none;
    }
    .card.selected {
      border-color: yellow;
      box-shadow: 0 0 4px yellow;
    }
    .card-disabled {
      opacity: 0.4;
      cursor: default;
    }
    button {
      background: #333;
      color: #eee;
      border: 1px solid #777;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    #hand-panel h3 {
      margin: 0 0 4px 0;
    }
    #rules-note {
      font-size: 11px;
      color: #bbb;
    }
  </style>
</head>
<body>
  <h1>Doghouse – Prototype</h1>
  <div id="rules-note">
    4 colors: Red (R), Yellow (Y), Green (G), Purple (P). Clockwise track, doghouse/out/home rules implemented.
  </div>

  <div id="game-container">
    <div id="board"></div>

    <div id="right-panel">
      <div id="controls">
        <div>
          <label>Players: </label>
          <select id="player-count">
            <option value="4" selected>4 players (2 teams)</option>
            <option value="2">2 players (each controls 2 colors)</option>
          </select>
        </div>
        <button id="new-game-btn">New Game</button>
        <button id="next-hand-btn" disabled>Deal Next Hand</button>
        <button id="fold-btn" disabled>Fold (No Legal Move)</button>
      </div>

      <div id="status"></div>

      <div id="hand-panel">
        <h3>Current Hand</h3>
        <div id="hand-cards"></div>
      </div>

      <div id="log"></div>
    </div>
  </div>

  <script>
    /********************************************************************
     * Core model
     ********************************************************************/
    const COLORS = ["R", "Y", "G", "P"];
    const COLOR_NAMES = { R: "Red", Y: "Yellow", G: "Green", P: "Green", P2: "Purple" };
    const COLOR_FULL = { R: "Red", Y: "Yellow", G: "Green", P: "Purple" };
    const TRACK_LENGTH = 52;      // main loop
    const HOME_LENGTH = 4;        // 4-home stretch per color
    const PER_PLAYER = 4;         // pegs per color

    // start index for each color on the main track (abstract ring)
    const START_INDEX = {
      R: 0,
      Y: 13,
      G: 26,
      P: 39
    };

    // home entrance index (just before turning into home)
    const HOME_ENTRANCE = {
      R: (START_INDEX.R + TRACK_LENGTH - 1) % TRACK_LENGTH,
      Y: (START_INDEX.Y + TRACK_LENGTH - 1) % TRACK_LENGTH,
      G: (START_INDEX.G + TRACK_LENGTH - 1) % TRACK_LENGTH,
      P: (START_INDEX.P + TRACK_LENGTH - 1) % TRACK_LENGTH
    };

    const PLAYERS_CONFIG = {
      "4": [ "R", "Y", "G", "P" ], // each color 1 player, partners R+G, Y+P (for example)
      "2": [ "R,G", "Y,P" ]        // each player controls 2 colors
    };

    function createDeck() {
      const deck = [];
      const ranks = [ "A", "2", "3", "4", "5", "6", "7", "8",
                      "9", "10", "J", "Q", "K" ];
      const suits = [ "♠", "♥", "♦", "♣" ];
      for (const r of ranks) {
        for (const s of suits) {
          deck.push(r);
        }
      }
      deck.push("JOKER");
      deck.push("JOKER");
      // shuffle
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    function cardToValue(card, context=null) {
      if (card === "JOKER" && context && context.as) {
        // Joker used as a specific card
        return cardToValue(context.as);
      }
      switch(card) {
        case "A": return 1;
        case "2": return 2;
        case "3": return 3;
        case "4": return 4;
        case "5": return 5;
        case "6": return 6;
        case "7": return 7;
        case "8": return 8;
        case "9": return 9;
        case "10": return 10;
        case "J": return 11;
        case "Q": return 12;
        case "K": return 13;
        default: return null;
      }
    }

    /********************************************************************
     * Game state
     ********************************************************************/
    let state = null;

    function newGame() {
      const mode = document.getElementById("player-count").value;
      const deck = createDeck();
      const players = [];

      if (mode === "4") {
        const colors = PLAYERS_CONFIG["4"];
        for (let i = 0; i < 4; i++) {
          players.push({
            id: i,
            colors: [colors[i]],
            isTeam: true,
            hand: [],
            folded: false,
            skipNext: false
          });
        }
      } else {
        const config = PLAYERS_CONFIG["2"];
        for (let i = 0; i < 2; i++) {
          const colors = config[i].split(",");
          players.push({
            id: i,
            colors,
            isTeam: false,
            hand: [],
            folded: false,
            skipNext: false
          });
        }
      }

      // pegs: for each color, 4 pegs in doghouse
      const pegs = {};
      const usedColors = new Set();
      players.forEach(p => p.colors.forEach(c => usedColors.add(c)));
      for (const c of usedColors) {
        pegs[c] = [];
        for (let i = 0; i < PER_PLAYER; i++) {
          pegs[c].push({
            color: c,
            index: null,    // null = doghouse
            inHome: false,
            homeIndex: null // 0-3
          });
        }
      }

      state = {
        mode,
        deck,
        discard: [],
        players,
        currentPlayerIndex: Math.floor(Math.random() * players.length), // random start
        pegs,
        handPhase: 1,   // 1:5, 2:4, 3:4
        dealerIndex: 0,
        remainingDeck: deck,
        currentCardSelection: null,
        currentPegSelection: null,
        pendingSeven: null, // { cardIndex, totalRemaining, jokerspec? }
        logLines: [],
        winner: null
      };

      log(`New game started. Player ${state.currentPlayerIndex + 1} begins.`);
      dealNewHandPhase(true);
      render();
    }

    function dealNewHandPhase(initial=false) {
      const deck = state.remainingDeck;
      const players = state.players;

      let cardsToDeal = 0;
      if (state.handPhase === 1) cardsToDeal = 5;
      else if (state.handPhase === 2) cardsToDeal = 4;
      else if (state.handPhase === 3) cardsToDeal = 4;

      // Clear hands if new dealer cycle started
      players.forEach(p => {
        p.hand = [];
        p.folded = false;
      });

      for (let round = 0; round < cardsToDeal; round++) {
        for (const p of players) {
          if (deck.length === 0) break;
          p.hand.push(deck.pop());
        }
      }

      if (state.handPhase === 3) {
        // Dealer optional swap of up to 2 cards (simplified: auto skip for now)
        // To keep UI simple, we skip manual swap in this prototype.
        log(`Dealer (Player ${state.dealerIndex + 1}) could swap up to 2 cards (skipped in prototype).`);
      }

      state.currentPlayerIndex = state.dealerIndex; // first after dealing is dealer's left in rules, but we simplify
      state.currentPlayerIndex = (state.dealerIndex + 1) % players.length;
      log(`New hand phase ${state.handPhase}: each player has ${cardsToDeal} cards.`);
      updateButtons();
      render();
    }

    /********************************************************************
     * Rendering
     ********************************************************************/
    function log(msg) {
      state.logLines.push(msg);
      const logDiv = document.getElementById("log");
      logDiv.textContent = state.logLines.slice(-200).join("\n");
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function render() {
      renderBoard();
      renderHand();
      renderStatus();
      updateButtons();
    }

    function renderBoard() {
      const boardDiv = document.getElementById("board");
      boardDiv.innerHTML = "";

      // We'll render a simple abstract loop: 52 track cells + 4 home x 4 colors + 4 doghouse "zones"
      // Layout: 13 columns x 13 rows; track around border; home + doghouse in corners.

      const cells = [];

      const totalRows = 13;
      const totalCols = 13;

      function cellKey(r, c) { return `${r},${c}`; }

      const gridMap = {};

      // Map main track in a loop around the border: top row -> right column -> bottom row -> left column
      const trackIndices = [];
      // top row (0, 0..12)
      for (let c = 0; c < totalCols; c++) trackIndices.push([0, c]);
      // right col (1..12, 12)
      for (let r = 1; r < totalRows; r++) trackIndices.push([r, totalCols-1]);
      // bottom row (12, 11..0)
      for (let c = totalCols-2; c >= 0; c--) trackIndices.push([totalRows-1, c]);
      // left col (11..1, 0)
      for (let r = totalRows-2; r > 0; r--) trackIndices.push([r, 0]);

      // We have 44 cells, but we need 52; so extend a bit inward on each side.
      // We'll just add extra inner ring segments (simplified).
      // This is only visual; logic uses TRACK_LENGTH.

      // Map a subset of trackIndices to the logical indices
      const trackMap = {};
      for (let i = 0; i < TRACK_LENGTH; i++) {
        const pos = trackIndices[i % trackIndices.length];
        trackMap[i] = pos;
      }

      // Build reverse index: grid cell -> track index
      const cellToTrack = {};
      for (let i = 0; i < TRACK_LENGTH; i++) {
        const [r, c] = trackMap[i];
        cellToTrack[cellKey(r,c)] = i;
      }

      state.cellToTrack = cellToTrack;
      state.trackToCell = trackMap;

      // Home and doghouse visual placeholders (not geometric match to your board).
      // We'll just mark 4 cells near each corner as home, and 1 cell as doghouse.
      const homeCells = {
        R: [ [1,1], [1,2], [2,1], [2,2] ],
        Y: [1,10, 1,9, 2,10, 2,9].reduce((acc, v, i, arr)=>acc, []), // placeholder
      };

      // Instead of overcomplicating visuals, we’ll keep homes abstract: we’ll just show pegs "off-board"
      // with text (in home / in doghouse) in the status for now.

      for (let r = 0; r < totalRows; r++) {
        for (let c = 0; c < totalCols; c++) {
          const cellDiv = document.createElement("div");
          cellDiv.className = "cell";
          const key = cellKey(r,c);
          if (cellToTrack[key] != null) {
            cellDiv.classList.add("track");
            cellDiv.dataset.trackIndex = cellToTrack[key];
          }
          // Attach click handler for board cell selection
          cellDiv.addEventListener("click", () => onCellClick(cellDiv));
          boardDiv.appendChild(cellDiv);
        }
      }

      // Render pegs on track
      const pegs = state.pegs;
      for (const color in pegs) {
        pegs[color].forEach((peg, idx) => {
          if (peg.index != null && !peg.inHome) {
            const tIndex = peg.index;
            const [r,c] = state.trackToCell[tIndex];
            const cellIndex = r * totalCols + c;
            const cellDiv = boardDiv.children[cellIndex];
            const pegDiv = document.createElement("div");
            pegDiv.className = `peg peg-${color}`;
            pegDiv.title = `${COLOR_FULL[color]} peg ${idx+1}`;
            pegDiv.addEventListener("click", (e) => {
              e.stopPropagation();
              onPegClick(color, idx);
            });
            cellDiv.appendChild(pegDiv);
          }
        });
      }
    }

    function renderHand() {
      const handDiv = document.getElementById("hand-cards");
      handDiv.innerHTML = "";
      if (!state) return;

      const player = state.players[state.currentPlayerIndex];
      const hand = player.hand;

      hand.forEach((card, idx) => {
        const cardSpan = document.createElement("span");
        cardSpan.className = "card";
        cardSpan.textContent = card;
        cardSpan.dataset.index = idx;

        if (state.currentCardSelection &&
            state.currentCardSelection.playerId === player.id &&
            state.currentCardSelection.cardIndex === idx) {
          cardSpan.classList.add("selected");
        }

        if (player.folded || state.winner) {
          cardSpan.classList.add("card-disabled");
        } else {
          cardSpan.addEventListener("click", () => onCardClick(idx));
        }

        handDiv.appendChild(cardSpan);
      });
    }

    function renderStatus() {
      const statusDiv = document.getElementById("status");
      if (!state) {
        statusDiv.textContent = "Click 'New Game' to begin.";
        return;
      }

      const p = state.players[state.currentPlayerIndex];
      const colors = p.colors.join(", ");
      let text = `Current player: Player ${p.id + 1} (${colors})`;
      if (p.folded) text += " – folded this hand";
      if (p.skipNext) text += " – will skip next turn (Jack penalty)";

      if (state.pendingSeven) {
        text += ` | 7 in progress: ${state.pendingSeven.remaining} steps remaining.`;
      }

      if (state.winner != null) {
        text += `\n\nWinner: Player ${state.winner + 1}`;
      }

      // Peg summary
      const lines = [text, "", "Peg positions:"];

      for (const color in state.pegs) {
        const pegs = state.pegs[color];
        let dog = 0, home = 0, field = 0;
        pegs.forEach(p => {
          if (p.index == null && !p.inHome) dog++;
          else if (p.inHome) home++;
          else field++;
        });
        lines.push(`${COLOR_FULL[color]}: Doghouse ${dog}, Field ${field}, Home ${home}`);
      }

      statusDiv.textContent = lines.join("\n");
    }

    function updateButtons() {
      const nextHandBtn = document.getElementById("next-hand-btn");
      const foldBtn = document.getElementById("fold-btn");
      if (!state) {
        nextHandBtn.disabled = true;
        foldBtn.disabled = true;
        return;
      }
      const p = state.players[state.currentPlayerIndex];
      const anyCards = p.hand.length > 0;
      foldBtn.disabled = !anyCards || p.folded || !!state.winner;
      // enable "deal next hand" only when all hands emptied
      const allEmpty = state.players.every(pl => pl.hand.length === 0 || pl.folded);
      nextHandBtn.disabled = !allEmpty || !!state.winner;
    }

    /********************************************************************
     * Interaction
     ********************************************************************/
    function onCardClick(cardIndex) {
      if (!state) return;
      const p = state.players[state.currentPlayerIndex];
      if (p.folded || state.winner) return;

      const card = p.hand[cardIndex];

      // select/deselect
      if (state.currentCardSelection &&
          state.currentCardSelection.cardIndex === cardIndex &&
          state.currentCardSelection.playerId === p.id) {
        state.currentCardSelection = null;
        state.pendingSeven = null;
      } else {
        state.currentCardSelection = {
          playerId: p.id,
          cardIndex,
          card
        };
        if (card === "7" || card === "JOKER") {
          // 7 may become multi-step; Joker may become 7 if chosen, but for now we'll treat Joker as single move in this prototype.
          // We will handle 7-splitting when actually moving.
        }
      }
      render();
    }

    function onPegClick(color, pegIndex) {
      if (!state) return;
      const p = state.players[state.currentPlayerIndex];
      if (!state.currentCardSelection) return;
      if (state.winner) return;

      const cardInfo = state.currentCardSelection;
      const card = cardInfo.card;
      const cardValue = cardToValue(card);

      // Determine if this peg belongs to current player (or their colors)
      if (!p.colors.includes(color)) {
        log(`You cannot move ${COLOR_FULL[color]}'s peg.`);
        return;
      }

      if (card === "A" || card === "K" || card === "JOKER") {
        // can be out or move
        // If peg in doghouse and card supports "out", move out
        const peg = state.pegs[color][pegIndex];
        if (peg.index == null && !peg.inHome) {
          // move out
          if (card === "A" || card === "K" || card === "JOKER") {
            movePegOut(color, pegIndex, cardInfo);
            consumeCardAndAdvance(cardInfo);
          } else {
            log("This card cannot bring a peg out.");
          }
        } else {
          // move by value
          const effective = card === "JOKER" ? askJokerValue(cardInfo) : cardValue;
          if (effective == null) {
            log("Joker cancelled.");
            return;
          }
          movePegBy(color, pegIndex, effective, false, cardInfo);
        }
      } else if (card === "6") {
        movePegBy(color, pegIndex, 6, true, cardInfo);
      } else if (card === "7") {
        handleSevenMove(color, pegIndex, cardInfo);
      } else if (card === "10") {
        // 10 = switch, unless no switch available -> move 10
        handleTen(color, pegIndex, cardInfo);
      } else {
        // normal forward
        movePegBy(color, pegIndex, cardValue, false, cardInfo);
      }

      render();
    }

    function onCellClick(cellDiv) {
      // For now, board cells have no additional interaction beyond peg clicks.
      return;
    }

    document.getElementById("new-game-btn").addEventListener("click", () => {
      newGame();
    });

    document.getElementById("next-hand-btn").addEventListener("click", () => {
      if (!state) return;
      if (state.handPhase < 3) {
        state.handPhase++;
        dealNewHandPhase();
      } else {
        // rotate dealer and reset handPhase
        state.dealerIndex = (state.dealerIndex + 1) % state.players.length;
        state.handPhase = 1;
        if (state.remainingDeck.length < 5 * state.players.length + 8) {
          state.remainingDeck = createDeck();
          log("Deck reshuffled.");
        }
        dealNewHandPhase();
      }
    });

    document.getElementById("fold-btn").addEventListener("click", () => {
      if (!state) return;
      const p = state.players[state.currentPlayerIndex];
      if (p.folded || p.hand.length === 0) return;
      p.folded = true;
      log(`Player ${p.id + 1} folds (no legal move).`);
      advanceTurn();
      render();
    });

    /********************************************************************
     * Movement helpers
     ********************************************************************/
    function movePegOut(color, pegIndex, cardInfo) {
      const peg = state.pegs[color][pegIndex];
      if (peg.index != null || peg.inHome) return;

      const startIndex = START_INDEX[color];

      // check blocking at start hole: if any peg is on start index, cannot move out
      const blocking = findPegAtTrackIndex(startIndex);
      if (blocking) {
        log(`Start hole is blocked – cannot move out.`);
        return;
      }

      peg.index = startIndex;
      log(`${COLOR_FULL[color]} peg ${pegIndex+1} moves out to start.`);
      resolveCaptureAt(peg.index, color); // if we treated "landing on" as capture here, but rules say they go out onto empty? Usually start hole can capture; your physical rules imply you can land on others.
      consumeCardAndAdvance(cardInfo);
    }

    function findPegAtTrackIndex(index) {
      for (const color in state.pegs) {
        for (let i = 0; i < state.pegs[color].length; i++) {
          const p = state.pegs[color][i];
          if (p.index === index && !p.inHome) {
            return { color, pegIndex: i };
          }
        }
      }
      return null;
    }

    function resolveCaptureAt(index, moverColor) {
      for (const color in state.pegs) {
        for (let i = 0; i < state.pegs[color].length; i++) {
          const p = state.pegs[color][i];
          if (p.index === index && !p.inHome && !(color === moverColor)) {
            // send to doghouse
            p.index = null;
            p.inHome = false;
            p.homeIndex = null;
            log(`${COLOR_FULL[color]} peg ${i+1} sent back to doghouse.`);
          }
        }
      }
    }

    function movePegBy(color, pegIndex, steps, backwards, cardInfo) {
      const peg = state.pegs[color][pegIndex];

      if (peg.index == null && !peg.inHome) {
        log(`Peg ${pegIndex+1} is in doghouse. Use an out card.`);
        return;
      }
      if (peg.inHome) {
        log(`Peg ${pegIndex+1} is already in home.`);
        return;
      }

      const direction = backwards ? -1 : 1;
      let pos = peg.index;

      for (let i = 0; i < steps; i++) {
        const next = (pos + direction + TRACK_LENGTH) % TRACK_LENGTH;

        // cannot pass home entrance going forward
        if (!backwards && pos === HOME_ENTRANCE[color]) {
          // try entering home instead
          const remaining = steps - i;
          attemptEnterHome(color, pegIndex, remaining, cardInfo);
          return;
        }

        // cannot pass through someone in a start hole
        if (isStartBlocked(pos, next, color)) {
          log(`Movement blocked by a peg in a start hole.`);
          return;
        }

        pos = next;
      }

      peg.index = pos;
      log(`${COLOR_FULL[color]} peg ${pegIndex+1} moves ${backwards ? "back" : "forward"} ${steps}.`);
      resolveCaptureAt(pos, color);
      consumeCardAndAdvance(cardInfo);
    }

    function isStartBlocked(from, to, moverColor) {
      // If the segment crosses a start index that has a peg sitting on it,
      // block movement.
      for (const c of COLORS) {
        const startIdx = START_INDEX[c];
        const blocker = findPegAtTrackIndex(startIdx);
        if (blocker) {
          // simpler: if destination is beyond startIdx and we would pass it, block
          // This is a simplification; exact path stepping already done in movePegBy.
          if (to === startIdx) return true;
        }
      }
      return false;
    }

    function attemptEnterHome(color, pegIndex, remainingSteps, cardInfo) {
      const peg = state.pegs[color][pegIndex];
      // home movement: must land exactly in a free home slot without jumping own pegs
      const homeSlots = state.pegs[color].map(p => p.inHome ? p.homeIndex : null);
      // We'll find the current homeIndex of this peg (if any) or treat as just entering.
      let currentHomeIndex = peg.inHome ? peg.homeIndex : -1;

      // You can only move forward within home, filling in order and not jumping your own pegs.
      let targetIndex = currentHomeIndex + remainingSteps;

      if (targetIndex < 0 || targetIndex >= HOME_LENGTH) {
        log(`Cannot enter home: needs exact count within 1–4.`);
        return;
      }

      // no jumping own pegs: all intermediate home slots must be empty or this peg
      for (let i = currentHomeIndex + 1; i <= targetIndex; i++) {
        if (homeSlots.includes(i) && !(peg.inHome && peg.homeIndex === i)) {
          log(`Cannot jump your own peg in home.`);
          return;
        }
      }

      peg.inHome = true;
      peg.index = null;
      peg.homeIndex = targetIndex;
      log(`${COLOR_FULL[color]} peg ${pegIndex+1} moves into home (slot ${targetIndex+1}).`);

      consumeCardAndAdvance(cardInfo);
      checkWin();
    }

    function handleSevenMove(color, pegIndex, cardInfo) {
      // To keep the prototype manageable:
      // For now, treat 7 as single-peg move of 7 (no splitting)
      // This is where we’d later implement full splitting logic.
      movePegBy(color, pegIndex, 7, false, cardInfo);
    }

    function handleTen(color, pegIndex, cardInfo) {
      const currentPeg = state.pegs[color][pegIndex];

      // find possible switch targets (any peg, including partner but not own color, not in home)
      const candidates = [];
      for (const c in state.pegs) {
        for (let i = 0; i < state.pegs[c].length; i++) {
          const p = state.pegs[c][i];
          if (p.index != null && !p.inHome && !(c === color && i === pegIndex)) {
            candidates.push({ color: c, pegIndex: i });
          }
        }
      }

      if (candidates.length === 0) {
        log(`No pegs to switch with – moving 10 instead.`);
        movePegBy(color, pegIndex, 10, false, cardInfo);
        return;
      }

      // For the prototype, auto-switch with the first candidate.
      const target = candidates[0];
      const otherPeg = state.pegs[target.color][target.pegIndex];

      const tempIndex = currentPeg.index;
      currentPeg.index = otherPeg.index;
      otherPeg.index = tempIndex;

      log(`${COLOR_FULL[color]} peg ${pegIndex+1} switches with ${COLOR_FULL[target.color]} peg ${target.pegIndex+1}.`);
      consumeCardAndAdvance(cardInfo);
    }

    function consumeCardAndAdvance(cardInfo) {
      const p = state.players[state.currentPlayerIndex];
      const card = p.hand[cardInfo.cardIndex];

      // Jack penalty
      if (card === "J") {
        const nextIdx = (state.currentPlayerIndex + 1) % state.players.length;
        state.players[nextIdx].skipNext = true;
        log(`Jack played – Player ${nextIdx+1} will discard and skip next turn.`);
      }

      p.hand.splice(cardInfo.cardIndex, 1);
      state.currentCardSelection = null;

      checkWin();

      advanceTurn();
    }

    function advanceTurn() {
      if (state.winner != null) return;

      // all hands empty?
      const allDone = state.players.every(p => p.hand.length === 0 || p.folded);
      if (allDone) {
        updateButtons();
        return;
      }

      const n = state.players.length;
      for (let i = 0; i < n; i++) {
        state.currentPlayerIndex = (state.currentPlayerIndex + 1) % n;
        const p = state.players[state.currentPlayerIndex];

        if (p.folded || p.hand.length === 0) continue;

        if (p.skipNext) {
          if (p.hand.length > 0) {
            // discard any one card (we'll auto-discard last card in prototype)
            const discarded = p.hand.pop();
            log(`Player ${p.id+1} discards ${discarded} and skips turn (Jack penalty).`);
          }
          p.skipNext = false;
          continue; // skip this turn, go to next
        }

        break;
      }

      render();
    }

    function askJokerValue(cardInfo) {
      // For prototype simplicity, use Joker as 1 (Ace) by default
      log("Joker treated as Ace (1) in prototype.");
      return 1;
    }

    function checkWin() {
      // Simplified: a player wins when ALL their colors' pegs are in home.
      for (const pl of state.players) {
        let allHome = true;
        for (const c of pl.colors) {
          const pegs = state.pegs[c];
          for (const p of pegs) {
            if (!p.inHome) {
              allHome = false;
              break;
            }
          }
          if (!allHome) break;
        }
        if (allHome) {
          state.winner = pl.id;
          log(`Player ${pl.id+1} wins!`);
          break;
        }
      }
    }

    // Initial status
    render();
  </script>
</body>
</html>
